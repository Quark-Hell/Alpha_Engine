#version 460
in vec3 color;
in vec3 normal;
in vec3 frag_Pos;
in vec2 texCoords;

out vec4 frag_color;

uniform vec3 viewPos;
uniform sampler2D diffuseMap;

vec3 calcAmbientLights(float strength, vec3 lColor);
vec3 calcDiffuseLight(vec3 ambient, vec3 norm, vec3 lightDir, float strength);
vec3 calcSpecularLight(vec3 lColor, vec3 norm, vec3 lightDir);

struct DirectLight {
    vec3 direction;
    vec3 color;
	float strength;

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};
#define MAXDIRECTLIGHT 8
uniform int DirectLightsCount = 0;
uniform DirectLight directLights[MAXDIRECTLIGHT];
vec3 calcDirectLight();

vec3 calcDirectLight(DirectLight dirLight, vec3 normal){
      vec3 lightDir = normalize(dirLight.direction);
	  
	  vec3 norm = normalize(normal);
   
      vec3 ambient = calcAmbientLights(dirLight.strength, dirLight.color);
      vec3 diffuse = calcDiffuseLight(dirLight.color, norm, lightDir, dirLight.strength);
      vec3 specular = calcSpecularLight(dirLight.color, norm, lightDir);
	  
	  vec3 result = ambient + diffuse + specular;
	  
	  return result;
}


struct PointLight {
    vec3 position;
    vec3 color;
	float strength;

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float constant;
    float linear;
    float quadratic;
};
#define MAXPOINTLIGHT 16
uniform int PointLightsCount = 0;
uniform PointLight pointLights[MAXPOINTLIGHT];

vec3 calcPointLight(PointLight pLight, vec3 normal);

vec3 calcPointLight(PointLight pLight, vec3 normal){
      //vec3 lightDir = normalize(lightPos - frag_Pos);
	  vec3 lightDir = normalize(pLight.position - frag_Pos);
	  
	  vec3 norm = normalize(normal);
   
      vec3 ambient = calcAmbientLights(pLight.strength, pLight.color) * vec3(texture(diffuseMap, texCoords));
      vec3 diffuse = calcDiffuseLight(pLight.color, norm, lightDir, pLight.strength) * vec3(texture(diffuseMap, texCoords));
      vec3 specular = calcSpecularLight(pLight.color, norm, lightDir);
	  
	  float distance    = length(pLight.position - frag_Pos);
	  float attenuation = 1.0 / (pLight.constant + pLight.linear * distance + 
    		    pLight.quadratic * (distance * distance));
	  
      //ambient *= attenuation;
	  diffuse *= attenuation;
	  specular *= attenuation;
	  
	  vec3 result = diffuse + ambient;
	  
	  return result;
}

struct SpotLight {
    vec3 color;
    vec3  position;
    vec3  direction;
	float strength;

    float cutOff;
};
#define MAXSPOTLIGHT 16
uniform int SpotLightsCount = 0;
uniform SpotLight spotLights[MAXSPOTLIGHT];

vec3 calcAmbientLights(float strength, vec3 lColor){
   float str = 0.35f;
   vec3 ambient = str * lColor;

   return ambient;
}


vec3 calcDiffuseLight(vec3 lColor, vec3 norm, vec3 lightDir, float strength){
   float diff = max(dot(norm, lightDir), 0.0);

   vec3 diffuse = lColor * diff * strength;

   return diffuse;
}

vec3 calcSpecularLight(vec3 lColor, vec3 norm, vec3 lightDir){
   vec3 viewDir = normalize(viewPos - frag_Pos);
   vec3 reflectDir = reflect(-lightDir, norm);
   
   float spec = pow(max(dot(viewDir, reflectDir), 0.0), 128);
   float specularStrength = 0.5f;
   vec3 specular = specularStrength * spec * lColor;
   
   return specular;
}

void main() {   
   vec3 result; 
   bool hasLight = false;

   for(int i = 0; i < DirectLightsCount && i < MAXDIRECTLIGHT; i++){
      hasLight = true;	  
	  result = calcDirectLight(directLights[i], normal) * vec3(texture(diffuseMap, texCoords));
   }
   
   for(int i = 0; i < PointLightsCount && i < MAXPOINTLIGHT; i++){
      hasLight = true;	  
	  result = calcPointLight(pointLights[i], normal);
   }
   
   vec3 n = normalize(normal);
   
   if(hasLight){
	frag_color = vec4(result, 1.0);
   }
   else{
	result = vec3(0.961, 0.478, 0.161);
	frag_color = vec4(result, 1.0);
   }
}