#version 460
in vec3 color;
in vec3 normal;
in vec3 frag_Pos;
in vec2 texCoords;

out vec4 frag_color;

uniform vec3 viewPos;
uniform sampler2D diffuseMap;
uniform float ambientStrength;

vec3 calcAmbientLights(float strength, vec3 lColor);
vec3 calcDiffuseLight(vec3 ambient, vec3 norm, vec3 lightDir, float strength);
vec3 calcSpecularLight(vec3 lColor, vec3 norm, vec3 lightDir);

struct DirectLight {
    vec3 direction;
    vec3 color;
	float strength;

    vec3 diffuse;
    vec3 specular;
};
#define MAXDIRECTLIGHT 8
uniform int DirectLightsCount = 0;
uniform DirectLight directLights[MAXDIRECTLIGHT];
vec3 calcDirectLight();

vec3 calcDirectLight(DirectLight dirLight, vec3 normal){
      vec3 lightDir = normalize(dirLight.direction);
	  
	  vec3 norm = normalize(normal);
   
      vec3 ambient = calcAmbientLights(dirLight.strength, dirLight.color);
      vec3 diffuse = calcDiffuseLight(dirLight.color, norm, lightDir, dirLight.strength);
      vec3 specular = calcSpecularLight(dirLight.color, norm, lightDir);
	  
	  vec3 result = ambient + diffuse + specular;
	  
	  return result;
}


struct PointLight {
    vec3 position;
    vec3 color;
	float strength;

    vec3 diffuse;
    vec3 specular;

    float constant;
    float linear;
    float quadratic;
};
#define MAXPOINTLIGHT 16
uniform int PointLightsCount = 0;
uniform PointLight pointLights[MAXPOINTLIGHT];

vec3 calcPointLight(PointLight pLight, vec3 normal);

vec3 calcPointLight(PointLight pLight, vec3 normal){
	  vec3 lightDir = normalize(pLight.position - frag_Pos);
	  
	  vec3 norm = normalize(normal);
   
      vec3 ambient = calcAmbientLights(pLight.strength, pLight.color) * vec3(texture(diffuseMap, texCoords));
      vec3 diffuse = calcDiffuseLight(pLight.color, norm, lightDir, pLight.strength) * vec3(texture(diffuseMap, texCoords));
      vec3 specular = calcSpecularLight(pLight.color, norm, lightDir);
	  
	  float distance    = length(pLight.position - frag_Pos);
	  float attenuation = 1.0 / (pLight.constant + pLight.linear * distance + 
    		    pLight.quadratic * (distance * distance));
	  
      //ambient *= attenuation;
	  diffuse *= attenuation;
	  specular *= attenuation;
	  
	  vec3 result = diffuse + ambient;
	  
	  return result;
}

struct SpotLight {
    vec3  direction;
    vec3 color;
	float strength;
    vec3  position;

    float cutOff;
	float outerCutOff;
};
#define MAXSPOTLIGHT 16
uniform int SpotLightsCount = 0;
uniform SpotLight spotLights[MAXSPOTLIGHT];

vec3 calcSpotLight(SpotLight sLight);

vec3 calcSpotLight(SpotLight sLight){
	vec3 lightDir = normalize(sLight.position - frag_Pos);
	vec3 norm = normalize(normal);
	
	vec3 ambient = calcAmbientLights(sLight.strength, sLight.color) * vec3(texture(diffuseMap, texCoords));
	vec3 diffuse = calcDiffuseLight(sLight.color, norm, lightDir, sLight.strength) * vec3(texture(diffuseMap, texCoords));
	vec3 specular = calcSpecularLight(sLight.color, norm, lightDir);
	
	float theta = dot(lightDir, normalize(-sLight.direction));
		if(theta > sLight.cutOff) 
		{       	
	
			vec3 result = ambient + diffuse;
			return result;
		}
		else{
			float epsilon   = sLight.cutOff - sLight.outerCutOff;
			float intensity = clamp((theta - sLight.outerCutOff) / epsilon, 0.0, 1.0); 		
			
			diffuse  *= intensity;
			specular *= intensity;
		
			vec3 result = ambient + diffuse;
			return result;
		} 	
}

vec3 calcAmbientLights(float strength, vec3 lColor){
   vec3 ambient = ambientStrength * lColor;

   return ambient;
}


vec3 calcDiffuseLight(vec3 lColor, vec3 norm, vec3 lightDir, float strength){
   float diff = max(dot(norm, lightDir), 0.0);

   vec3 diffuse = lColor * diff * strength;

   return diffuse;
}

vec3 calcSpecularLight(vec3 lColor, vec3 norm, vec3 lightDir){
   vec3 viewDir = normalize(viewPos - frag_Pos);
   vec3 reflectDir = reflect(-lightDir, norm);
   
   float spec = pow(max(dot(viewDir, reflectDir), 0.0), 128);
   float specularStrength = 0.5f;
   vec3 specular = specularStrength * spec * lColor;
   
   return specular;
}

void main() {   
   vec3 result; 
   bool hasLight = false;

   for(int i = 0; i < DirectLightsCount && i < MAXDIRECTLIGHT; i++){
      hasLight = true;	  
	  result = calcDirectLight(directLights[i], normal) * vec3(texture(diffuseMap, texCoords));
   }
   
   for(int i = 0; i < PointLightsCount && i < MAXPOINTLIGHT; i++){
      hasLight = true;	  
	  result = calcPointLight(pointLights[i], normal);
   }
      for(int i = 0; i < SpotLightsCount && i < MAXSPOTLIGHT; i++){
      hasLight = true;	  
	  result = calcSpotLight(spotLights[i]);
   }
   
   if(hasLight){
	frag_color = vec4(result, 1.0);
   }
   else{
    vec3 ambient = calcAmbientLights(ambientStrength, vec3(1,1,1)) * vec3(texture(diffuseMap, texCoords));
	frag_color = vec4(ambient, 1.0);
   }
}